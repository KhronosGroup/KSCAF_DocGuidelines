// (C) Copyright 2014-2018 The Khronos Group Inc. All Rights Reserved.
// Khronos Group Safety Critical API Development SCAP
// document
//
// Text format: asciidoc 8.6.9
// Editor:      Asciidoc Book Editor
//
// Description: Guidelines 3.2.16 Guidelines Git #32 #33 and #34

:Author: Bogdan Naodovic
:Author Initials: BN
:Revision: 0.06

// Hyperlink anchor, the ID matches those in
// 3_1_GuidelinesList.adoc
[[gh32]]

ifdef::basebackend-docbook[]
=== SC API-implementation details
endif::[]
ifdef::basebackend-html[]
=== {chapter-id}.{chapter-sub-id}.{counter:section-id}. SC API-implementation considerations
endif::[]

// Automatic sub-section numbering, use {counter:subsection-id}
:subsection-id: 0

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss API-implementation details as much as needed to ensure safety

*Rationale:* Safety environment places additional requirements on the implementation of an API, when compared to non-safety environment. If the impact of these additional requirements is not taken into account and discussed as needed in the SC version of the API, the SC version may inadvertently define functions, data structures or procedures which are infeasible to implement in the safety environment.

*Example:* Function `Buffer* get_buffer()` is declared in the SC version of the API, such that each time it is called, it allocates a new `Buffer` object and returns pointer to it. Since safety-critical execution typically has very strict requirements for memory allocation, a discussion section in the SC profile could:
[indent=2]
1. Limit the number of objects, which can be allocated, to value _N_, and specify an alternative version of the function, such as `Buffer* get_buffer(uint16_t i)`, which returns object with index `i`, where `i` can take a value between 0 and _(N-1)_. This way, the implementation can employ a strategy such as allocating all objects before the function is called the first time, or dynamically allocating an object whenever the function is called, but allocating it in a special section of memory designated exclusively for this purpose.
2. Limit the availability of new-object allocation to only certain modes of the system operation, such as non-safe initialization mode, and specify that the function may return `nullptr` when the system is not in one of those modes, to indicate that the allocation has not been, and cannot be, performed. With such a limitation, there would also have to be a function specified for querying the current mode of the system, such as `Mode get_mode()`, in order to be able to interpret results from calls to the mentioned function `get_buffer`, where `Mode` can be defined as `enum class Mode { non_safe, safe }`. An example of how these two functions could be used is shown below.
----
Buffer* input = get_buffer();
if (input == nullptr) {
    if (get_mode() == Mode::non_safe) {
        /* Handle being out of memory */
    } else if (get_mode()  == Mode::safe) {
        /* Handle being restricted from allocating new objects */
    };
}
----

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss API-implementation dependence on OS mechanisms

*Rationale:* Some API functions may be feasible to implement only if an OS provides certain mechanisms; therefore, it would be beneficial to discuss in the API specification about minimum requirements for the OS, since many safety-critical OS provide only minimal set of such mechanisms.

*Example:* <<ARINC 653 Time Partitioning & Hard Time Partitioning>> example in section 3.2.1

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss the impact of functions with broad-range parameters values on the testability of the implementation of the API

*Rationale:* Safety environment places additional requirements on testing of the implementation of an API, when compared to non-safety environment. These additional requirements typically ask for significantly more detailed and exhaustive testing than in the non-safety environment. If an API function has a parameter with a broad range of possible values, then it may be infeasible to implement the mentioned testing. If no narrow-range parameter alternatives exist, then the reasons should be listed in a discussion section. This section can then be referenced in safety report of the API implementation.

*Example:* Function `void initialize_display(uint64_t handle)` is defined in SC version of the API, such that it initializes resources needed by a particular display driver, in a system consisting of several display drivers. Since it is infeasible to determine which values of `handle` are allowed, a discussion section in the SC profile should state that:

* alternatives for the function are not possible in the API specification, since it cannot be known which drivers will be part of the system at the time of creation of the specification,
* the implementation is free to define finite set of allowed values for the `handle`.
This would simplify and improve testing by significantly reducing the number of test cases needed to be executed.

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss the impact of functions with parameters, for which allowed and disallowed sets of values are complex to determine, on testability of the implementation of the API

*Rationale:* Safety environment places additional requirements on testing of the implementation of an API, when compared to non-safety environment. These additional requirements typically ask for significantly more detailed and exhaustive testing than in the non-safety environment. If an API function has a parameter, for which allowed and disallowed sets of values are complex to determine, then it may be infeasible to implement the mentioned testing. If no simpler parameter alternatives exist, then the reasons should be listed in a discussion section. This section can then be referenced in safety report of the API implementation.

*Example:* Function `void get_driver_handles(void* handles, uint16_t max_num)` is defined in SC version of the API, such that it writes an array of handles in memory starting from address `handles`. No more than `max-num` elements are written in memory. Since it is complex to determine which values of `handles` are allowed, a discussion section in the SC profile could provide two functions as alternative to the mentioned `get_driver_handles`: 

* `uint16_t get_num_drivers()`,
* `uint64_t get_driver_handle(uint16_t i)`,
such that the former function returns number of drivers in the system, and the latter returns the handle from the driver with index `i`, where `i` can take a value between 0 and `get_num_drivers()`-result. Implementation of the alternative would simplify and improve testing by significantly reducing the number of test cases needed to be executed.

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss impact of functions with broad-range parameters on testability of user code calling those functions

*Rationale:* Safety environment places additional requirements on testing of the implementation of an API, when compared to non-safety environment. These additional requirements typically ask for parameter values passed to library functions to be tested for correctness. If there is user code calling an API function with a broad-range parameter, then it may be infeasible to implement the mentioned testing. If no narrow-range parameter alternatives exist, then the reasons should be listed in a discussion section. This section can then be referenced in safety report of the user code.

*Example:* See example [...]. In addition, the discussion section in the SC profile could suggest that the user code define function `void initialize_display(Driver_handle handle)`, where type of `handle` is `enum class Driver_handle : uint16_t { Driver_a, Driver_b}`, and `Driver_a` and `Driver_b` are the only allowed values for the parameter. Simple implementation of this function is shown below. This would simplify and improve testing by significantly reducing the number of test cases needed to be executed.

----
void initialize_display(Driver_handle handle)
{
    initialize_display(static_cast<uint16_t>(handle));
}
----

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss impact of functions with parameters, for which allowed and disallowed sets of values are complex to determine, on testability of user code calling those functions.

*Rationale:* Safety environment places additional requirements on testing of the implementation of an API, when compared to non-safety environment. These additional requirements typically ask for parameter values passed to library functions to be tested for correctness. If there is user code calling an API function with parameters, for which allowed and disallowed sets of values are complex to determine, then it may be infeasible to implement the mentioned testing. If no simpler parameter alternatives exist, then the reasons should be listed in a discussion section. This section can then be referenced in safety report of the user code.

*Example:* Function `void get_driver_handles(void* handles, uint16_t max_num)` is defined in SC version of the API, such that it writes an array of handles in memory starting from address `handles`. No more than `max-num` elements are written in memory. Since it is complex to determine which values of `handles` are allowed, a discussion section in the SC profile could suggest that the user code define function `std::vector<uint64_t> get_driver_handles()`. Simple implementaion of this function is shown below. This would simplify and improve testing by significantly reducing the number of test cases needed to be executed.

----
const uint16_t N = <maximum-value>;
std::vector<uint64_t> get_driver_handles()
{
    std::vetor<uint64_t> result;
    static uint64_t* handles = nullptr;
    if (handles == nullptr) {
        // To do: free 'handles'
        handles = new uint64_t[N];
        get_driver_handles(handles, N);
    }
    for (uint16_t i = 0; (i < N) && (*(handles + i) != 0); i++) {
        result.push_back(*(handles + i));
    }
    return result;
}
----
