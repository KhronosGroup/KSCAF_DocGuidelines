// (C) Copyright 2014-2018 The Khronos Group Inc. All Rights Reserved.
// Khronos Group Safety Critical API Development SCAP
// document
//
// Text format: asciidoc 8.6.9
// Editor:      Asciidoc Book Editor
//
// Description: Guidelines 3.2.16 Guidelines Git #32 #33 and #34

:Author: Bogdan Naodovic
:Author Initials: BN
:Revision: 0.06

// Hyperlink anchor, the ID matches those in
// 3_1_GuidelinesList.adoc
[[gh32]]

ifdef::basebackend-docbook[]
=== SC API-implementation details
endif::[]
ifdef::basebackend-html[]
=== {chapter-id}.{chapter-sub-id}.{counter:section-id}. SC API-implementation considerations
endif::[]

// Automatic sub-section numbering, use {counter:subsection-id}
:subsection-id: 0

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss API-implementation details as much as needed to ensure safety

*Rationale:* Safety environment places additional requirements on the implementation of an API, when compared to non-safety environment. If the impact of these additional requirements is not taken into account and discussed as needed in the SC version of the API, the SC version may inadvertently define functions, data structures or procedures which are infeasible to implement in the safety environment.

*Example:* Function `void* f()` is declared in the SC version of the API, such that each time it is called, it allocates a new object and returns pointer to it. Since safety-critical execution typically requires minimal memory allocation, such a function is all but in contradiction with the requirement. To overcome this contradiction, a discussion section in the SC profile could:
[indent=2]
1. Limit the number of objects which can be allocated to value _N_ and specify an alternative version of the function, such as `void* f(int i)`, which returns one of those _N_ objects, as specified by parameter `i`. This way, the implementation can employ a strategy that will be less in contradiction to safety requirements, such as allocating all objects in advance, or allocating the object as needed, but in a special section of memory designated exclusively for allocations by the mentioned function.
2. Limit the availability of new-object allocation to only certain stages of the system operation, such as pre-safety initialization stage, and specify that the function may return null pointer when the system is not in one of those stages, to indicate that the allocation has not been and cannot be performed. With such a limitation, there would also have to be a function specified for querying the current stage of the system, such as `int state()`, in order to be able to interpret results from calls to the mentioned function `f`. An example of how these two functions could be used is shown below.
----
void* object = f();
if (object == NULL) {
    if (stage() == PRE_SAFETY_INITIALIZATION) {
        /* Handle being out of memory */
    } else if (stage() == SAFETY) {
        /* Handle being unable to allocate new objects */
    } else {
        /* Handle general problem with allocation */
    }
}
----

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss API-implementation dependence on OS mechanisms

*Rationale:* Some API functions may be feasible to implement only if an OS provides certain mechanisms; therefore, it would be beneficial to discuss in the API specification about minimum requirements for the OS, since many safety-critical OS provide only minimal set of such mechanisms.

*Example:* <<ARINC 653 Time Partitioning & Hard Time Partitioning>> example in section 3.2.1

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss the impact of functions with a broad-range of parameters on the testability of the implementation of the API

*Rationale:* Implementations in the safety environment have a requirement for a significantly more detailed and exhaustive testing than in the non-safety environment. If an API function has a parameter with a broad range of possible values, then it may be infeasible to implement all the testing specified by various safety standards to which the API implementation may need to adhere to. If no alternatives for the function exist with a narrow-range of parameters, then there should be reasons listed in a discussion section why no alternative exists. This section can then be referenced in safety reports of the API implementations.

*Example:* [TODO]

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss the impact of functions with parameters for which allowed and disallowed sets of values are hard to determine on testability of the implementation of the API

*Rationale:* Implementations in the safety environment have a requirement for a significantly more detailed and exhaustive testing than in the non-safety environment. If an API function has a parameter for which there are allowed and disallowed sets of values which are hard to determine, then it may be infeasible to implement all the testing specified by various safety standards to which the API implementation may need to adhere to. If no alternatives for the function exist with a  parameter for which the mentioned sets can be feasibly determined, then there should be reasons listed in a discussion section why no alternative exists. This section can then be referenced in safety reports of the API implementations.

*Example:* [TODO]

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should discuss impact of functions with broad-range parameter or parameters on testability of user code calling those functions.

*Rationale:* A typical requirement for development in the safety environment is for parameter values passed to library functions to be tested for correctness. If there is user code calling an API function with a broad-range parameter, then it may be infeasible to implement all the testing specified by various safety standards to which the user code may need to adhere to. If no alternatives for the function exist with narrow-range parameters, then there should be reasons listed in a discussion section why no alternative exists. This section could then be referenced in safety report which encompasses the mentioned code.

*Example:* [TODO]

==== {chapter-id}.{chapter-sub-id}.{section-id}.{counter:subsection-id}. The SC version of an API should the discuss impact of functions with parameter(s) that allow and disallow sets of values that are hard to be verified by the users' testing applications.

*Rationale:* A typical requirement for development in the safety environment is for parameter values passed to library functions to be tested for correctness. If there is user code calling an API function with a parameter for which it is allowed and disallowed sets of values which are hard to determine, then it may be infeasible to implement all the testing specified by various safety standards to which the code may need to adhere to. If no alternatives for the function exist with the parameter for which the mentioned sets can be feasibly determined, then there should be reasons listed in a discussion section why no alternative exists. This section can then be referenced in safety report which encompasses the mentioned code.

*Example:* [TODO]
